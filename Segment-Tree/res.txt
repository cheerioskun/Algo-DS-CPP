#include<bits/stdc++.h>\n\nclass SegTree{\n    private:\n    int* T; // Main array that stores f(a[l]..a[r])\n    int* U;  // Stores whether to update \n    int* V;  // Stores the update values\n    int size;\n    public:\n    SegTree(int N, int* a){\n        T = new int[4 * N]();\n        U = new int[4 * N]();\n        V = new int[4 * N]();\n        size = N;\n        build(a, 0, 0, N - 1);\n    }\n    void build(int* a, int root, int l, int r){\n        if(l > r) return;\n        if(l == r){\n            // Changeable line\n            //T[root] = ;\n        }\n        else{\n            build(a, root * 2 + 1, l, (l + r)/ 2);\n            build(a, root * 2 + 2, (l + r)/ 2 + 1, r);\n            //T[root] = f(T[root * 2 + 1], T[root * 2 + 2]);\n        }\n    }\n    void update(int root, int x, int l, int r, int i, int j){\n        if(i > r || j < l) return;  // No overlap in range\n        if(l == r){\n            //T[root] = f(u(T[root], x), 0);\n        }\n        if(U[root]){ // If previous update is pending\n            update(root * 2 + 1, V[root], l, (l + r) / 2, i, j);\n            update(root * 2 + 2, V[root],(l + r) / 2 + 1, r, i, j);\n            //U[root] = 0;\n        }\n        if(i <= l && r <= j){   // Completely covered\n            U[root] = 1;\n            V[root] = x;\n            //T[root] = ru(x, (r - l + 1));\n        }\n        else{\n            update(root * 2 + 1, x, l, (l + r) / 2, i, j);\n            update(root * 2 + 2, x, (l + r) / 2 + 1, r, i, j);\n            //T[root] = f(T[root * 2 + 1], T[root * 2 + 2]);\n        }\n    }\n    void update(int x, int l, int r){\n        update(0, x, 0 , size - 1, l , r);\n    }\n    int query(int root, int l, int r, int i, int j){\n        if(i > r || j < l){\n            return -1;\n        }\n        // Check if query pending\n        if(U[root]){\n            update(root * 2 + 1, V[root], l, (l +r) / 2, i, j);\n            update(root * 2 + 2, V[root], (l +r) / 2 + 1, r, i, j);\n            U[root] = 0;\n        }\n        if(i <= l && r <= j){\n            return T[root];\n        }else{\n            int p1 = query(root * 2 + 1, l, (l + r) / 2, i , j);\n            int p2 = query(root * 2 + 2, (l + r) / 2 + 1, r, i , j);\n            //return f(p1, p2);\n        }\n    }\n    int query(int l, int r){\n        return query(0, 0, size - 1, l , r);\n    }\n};\n